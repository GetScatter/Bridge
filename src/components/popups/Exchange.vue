<template>
	<section class="transfer">
		<section class="popup-content" v-if="token">

			<TransferHead :hide="showingMore"
			              :token="token"
			              v-on:amount="x => token.amount = x"
			              :title="`How much <span>${fromToken.symbol}</span> do you want to convert to <span>${convertedToken ? convertedToken.symbol : ''}</span>?`"
			              :subtitle="loadingPairs ? 'Loading Tokens' : 'Select a token to convert to'" />


			<SearchBar v-on:terms="x => terms = x" style="margin-top:-10px;" v-if="showingMore" />

			<section class="loading-pairs" v-if="loadingPairs">
				<i class="animate-spin fas fa-spinner"></i>
			</section>

			<section class="select" v-if="!loadingPairs">
				<transition-group name="hide-for-select" class="options" :class="{'wrapping':showingMore}">
					<section :key="token.unique()" class="option" @click="selectToken(token)" v-for="token in tokens" :class="{'selected':convertedToken && token.unique() === convertedToken.unique()}">
						<SymbolBall :token="token" />
						<figure class="text">{{token.symbol}}</figure>
					</section>
					<section key="more-tokens" class="option">
						<section v-if="!showingMore" @click="showingMore = true">
							<SymbolBall symbol="fas fa-plus" />
							<figure class="text">{{pairs.length - 2}} others</figure>
						</section>
					</section>
				</transition-group>
			</section>

			<section v-if="!showingMore && convertedToken">
				<section class="receiving" v-if="!loadingRate">
					You will get <b>{{formatNumber(receiving)}} {{convertedToken.symbol}}</b>
				</section>
				<section class="receiving" v-if="loadingRate">
					Please wait while we load conversion rates
				</section>
			</section>
		</section>

		<section class="popup-buttons">
			<Button secondary="1" @click.native="() => closer(null)" text="Cancel" />
			<Button :loading="sending" primary="1" text="Exchange" @click.native="exchange" />
		</section>


	</section>
</template>

<script>
	import "../../styles/transfers.scss";
	import Hasher from "@walletpack/core/util/Hasher";
	import SymbolBall from "../reusable/SymbolBall";
	import BalanceService from "@walletpack/core/services/blockchain/BalanceService";
	import {mapActions, mapState} from "vuex";
	import TransferHead from "../reusable/TransferHead";
	import PriceService from "@walletpack/core/services/apis/PriceService";
	import ExchangeService from "@walletpack/core/services/apis/ExchangeService";
	import * as Actions from "@walletpack/core/store/constants";
	import HistoricExchange from "@walletpack/core/models/histories/HistoricExchange";
	import TokenService from "@walletpack/core/services/utility/TokenService";
	import TransferService from "@walletpack/core/services/blockchain/TransferService";
	import Popups from "../../util/Popups";
	import PopupService from "../../services/utility/PopupService";

	export default {
		props:['popin', 'closer'],
		components: {TransferHead, SymbolBall},
		data(){return {
			convertedToken:null,
			showingMore:false,
			terms:'',

			token:null,
			rate:null,
			loadingPairs:false,
			loadingRate:false,
			sending:false,

			rawPairs:[],
			pairs:[],
		}},
		computed:{
			...mapState([
				'isMobile'
			]),
			fromToken(){
				return this.popin.data.props.token;
			},
			tokens(){
				let balances = this.pairs;
				balances = balances.filter(x => x.symbol.toLowerCase().indexOf(this.terms) > -1);
				balances = balances.sort((a,b) => {
					const isSelected = this.convertedToken && b.unique() === this.convertedToken.unique() ? 1 : this.convertedToken && a.unique() === this.convertedToken.unique() ? -1 : 0;
					return isSelected;
				});

				if(!this.showingMore){
					balances = balances.slice(0,2);
				}

				return balances;
			},
			receiving(){
				if(!this.rate) return 0;
				if(!this.convertedToken) return 0;
				return parseFloat(this.rate.rate * this.token.amount).toFixed(this.convertedToken.decimals);
			},
			rawPair(){
				if(!this.convertedToken) return;
				return this.rawPairs.find(x => x.token.id === this.convertedToken.id);
			},
			withinMinMax(){
				return  (this.rate.min === null || this.rate.min <= this.receiving) &&
						(this.rate.max === null || this.rate.max >= this.receiving)
			},
		},
		created(){
			(async () => {
				PriceService.setPrices();

				this.token = this.fromToken.clone();
				this.token.amount = null;
				await this.getPairs();

				this.selectToken(this.pairs[0]);
			})();
		},
		methods:{
			selectToken(token){
				this.convertedToken = token;
				this.showingMore = false;
				this.terms = '';
				this.getRate();
			},


			async getPairs(){
				this.convertedToken = null;
				this.pairs = [];
				this.loadingPairs = true;
				let pairs = await ExchangeService.pairs(this.token);
				let {base, stable} = pairs;

				const tokensFor = x => x.map(y => y.token);

				this.pairs = tokensFor(base)
					.concat(tokensFor(stable))

				Object.keys(pairs).map(key => {
					if(key !== 'base' && key !== 'stable'){
						this.pairs = this.pairs.concat(tokensFor(pairs[key]));
					}
				})

				this.rawPairs = Object.keys(pairs).reduce((acc,key) => {
					acc = acc.concat(pairs[key]);
					return acc;
				}, []);


				this.loadingPairs = false;
			},
			async getRate(){
				this.loadingRate = true;
				this.rate = null;
				this.rate = await ExchangeService.rate(this.token, this.rawPair.symbol, this.rawPair.service);
				this.loadingRate = false;
			},


			async exchange(){
				if(this.sending) return;

				const cancel = msg => {
					this.sending = false;
					return PopupService.push(Popups.snackbar(msg));
				}

				if(!this.convertedToken) return cancel("You must select a token to convert to first");
				if(this.token.amount <= 0) return cancel(`The amount to convert must be over 0 ${this.token.symbol}`);
				if(!this.withinMinMax) return cancel(`The minimum for this conversion is ${this.rate.min} ${this.convertedToken.symbol} and the max is ${this.rate.max} ${this.convertedToken.symbol}`);

				this.sending = true;

				const account = this.token.accounts(true)[0];
				if(!account) return cancel(`There was an error getting the account that holds this ${this.token.symbol}.`);

				const recipient = this.convertedToken.accounts(true)[0];
				if(!recipient) return cancel(`There was an error getting an account that can hold ${this.convertedToken.symbol}.`);


				const from = { account:account.sendable() };
				const to = { account:recipient };
				const amount = this.token.amount;
				const order = await ExchangeService.order(this.rawPair.service, this.token, this.convertedToken.symbol, amount, from, to);

				if(!order) return cancel('There was an issue connecting to the Scatter API');

				const accounts = {
					from:from.account,
					to:to.account,
				}

				const symbols = {
					from:this.token.symbol,
					to:this.convertedToken.symbol
				}

				ExchangeService.accepted(order.id);
				const sent = await TransferService[account.blockchain()]({
					account:account,
					recipient:order.account,
					amount,
					memo:order.memo,
					token:this.token,
					promptForSignature:false,
					bypassHistory:true,
				}).catch(err => {
					PopupService.push(Popups.snackbar(`There was an error converting: ${err}`))
					return false
				});

				if(sent){
					if(!TokenService.hasToken(this.rawPair.token)){
						if(!!this.rawPair.token.contract && !!this.rawPair.token.contract.length) {
							await TokenService.addToken(this.rawPair.token, false, false);
						}
					}
					const history = new HistoricExchange(account, this.recipient, this.token, this.convertedToken, order, TransferService.getTransferId(sent, this.token.blockchain));
					this[Actions.DELTA_HISTORY](history);
					setTimeout(() => {
						ExchangeService.watch(history);
						BalanceService.loadBalancesFor(account);
					}, 1000);
				}
				this.sending = false;
			},


			...mapActions([
				Actions.DELTA_HISTORY
			])
		}
	}
</script>

<style scoped lang="scss">
	@import "../../styles/variables";

	.loading-pairs {
		height:67px;
		font-size: 36px;
		display:flex;
		justify-content: center;
		align-items: center;
		color:$grey;
	}

</style>